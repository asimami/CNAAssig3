#!/usr/bin/env python3

#Importing the needed python library for this assiginment.
import sys
import copy
from collections import defaultdict

INF = float('inf')

#Defining the Router class for the Distance Vector
class Router:
    # Creating the consturntion funciton for the routing class
    def __init__(self, router_name):
        self.router_name = router_name
        self.neighbors = {}
        self.routing_cost = {}
        self.distance_table = defaultdict(dict)
    
    # Creating the initialize_rotuer function that have two paprertmers self and router.
    def initialize_router(self, routers):
        # Usng the for loop to inisilize the distance table for all the destivnation throguh all neighbours.
        for destination_router in routers:
            for neighbors in routers:
                if neighbors != self.router_name:
                    self.distance_table[destination_router][neighbors] = INF

        # Usng the for loop to inizlise the routning cost to all the destioantion.
        for destination_router in routers:
            if destination_router == self.router_name:
                self.routing_cost[destination_router] = 0 #0 cost to reach to self.
            elif destination_router in self.neighbors:
                self.routing_cost[destination_router] = self.neighbors[destination_router]
            else: 
                self.routing_cost[destination_router] = INF
            
            for neighbors in self.neighbors:
                self.distance_table[destination_router][neighbors] = INF
        # Using the for loop to set the cost to each neighnbour that goes throguh itelsef.
        for neighbors in self.neighbors:
            self.distance_table[neighbors][neighbors] = self.neighbors[neighbors]

    # Creating the function with name updating_routing_cost which updates the routing cost everytime when find shortest path.
    def updating_routing_cost(self, router_network):
        table_updated = False #Putting the update false inisilly

        # Using the for loop to iterato over all the routers present in the network.
        for destination_router in router_network:
            if destination_router == self.router_name:
                continue
            # Inisliign the minmimum_cost anf tthe next hop
            minimum_cost = INF
            next_hop = None
            # Using the for loop to check the cost to reach the destination router via each neighbours present in the network.
            for neighbors in self.neighbors:
                cost_to_reach_neighbor = self.neighbors[neighbors]
                cost_coming_from_neighbor = router_network[router_network].routing_cost.get(destination_router, INF)
                final_cost = cost_to_reach_neighbor + cost_coming_from_neighbor
                self.distance_table[destination_router][neighbors] = final_cost
                # Using the if condition to cehck if the cost is better then previous cost.
                if final_cost < minimum_cost or (final_cost == minimum_cost and (next_hop is None or neighbors < next_hop)):
                    minimum_cost = final_cost
                    next_hop = neighbors
            # If the minimum cost is found update the cost in the tbale
            if self.routing_cost.get(destination_router, INF) != minimum_cost:
                self.routing_cost[destination_router] = minimum_cost
                table_updated = True # updating the table with new cost
        return table_updated #Returning the updated routing table after getting the new cost.

    # Creating the function that prints out the distance table for all the X, Y and Z routers.
    def printing_distance_table(self, routers, time_step):
        print(f"Distance Table of router {self.router_name} at t={time_step}:")
        table_headers = sorted(routers.keys())
        table_headers.remove(self.router_name)
        via = sorted(routers.keys())
        via.remove(self.router_name)

        #Ptining the headers of the distance tables
        routing_via_header = " " + "".join(f"{v:>6}" for v in via)
        print(routing_via_header)

        #Printing each row in the distance table.
        for destination_router in table_headers:
            table_row = f"{destination_router:<5}"
            for v in via:
                total_cost = self.distance_table[destination_router].get(v, INF)
                table_row += f"{('INF' if total_cost == INF else str(total_cost)):>6}"
            print(table_row)
        print()
    # Creating the function with name printing_routing_table that prints out the routing table for all the routers X, Y and Z. 
    def printing_routing_table(self, routers):
        print(f"Routing Table of router {self.router_name}:")
        # Sorting the routers list expecte the router itself.
        destinations = sorted([r for r in routers if r != self.router_name])
        # Using the for loop to loop the destination for each routers
        for destination_router in destinations:
            minimum_cost = self.routing_cost[destination_router]
            next_hop = None
            # Using the for loop to check the each niegbours that are in sorted orders to get the shorttest path 
            for neighbors in sorted(self.neighbors):
                if self.distance_table[destination_router].get(neighbors, INF) == minimum_cost:
                    next_hop = neighbors
                    break
            if minimum_cost == INF:
                # Printing the INF if the destination is not reachable via that route.
                print(f"{destination_router}, INF,INF")
            else:
                print(f"{destination_router},{next_hop},{minimum_cost}") #Else printing the values of destination router, next hop and mininmum cost.
        print()